'''
시간: 23:40 ~ 12:54(1시간 14분) / 실패

풀이 결과
1. 시작점 완전탐색 
  - 시간초과로 실패
2. 메모이제이션 방식으로 방문 처리하도록 수정
  - 시간초과로 실패
3. 탐색과 동시에 최댓값 계산하도록 수정
  - 실패(34 > 36% 지점에서 동일하게 실패하는 것으로 보아 전체 탐색 한번 더하는 것과는 관계없는 듯 하다.)
4. 깊이우선탐색으로 변경
  - 런타임 에러(RecursionError) 
  - 재귀가 너무 많은듯 하다. 다른 방법이 필요함.
5. dfs 탐색 + 큐를 활용하여 이전 위치를 저장시켜 재귀를 줄이자.
  - 34 > 36% 지점에서 시간초과로 실패
6. dfs 로 탐색하며 현재 위치부터 가능한 최댓값을 저장시킨다.
  - 단순히 저장하고 이동하는 것이 아니라, 갈 수 있는 곳의 값을 받아 현재 위치와 비교해 최댓값을 반드시 저장시켜야 한다.
  - 이 경우, 해당 위치는 무조건 최대값이 저장되어있기 때문에 더이상 진행할 필요가 없다.
  - 즉, 메모이제이션된 지점은 해당 위치 기준 갈 수 있는 최댓값이 되도록 코드를 작성해야 한다.

문제 분석
n*n 그래프
판다가 대나무 먹고 상하좌우 이동
현재 위치에서 먹은 대나무보다 많은 지역으로만 이동한다.

어떤 경로로 이동할 경우, 최대한 많은 칸을 이동시킬 수 있는지 찾아 최대 이동 칸 수를 출력하시오.

문제 풀이
1. 모든 위치에서 시작해보기 -> 완전탐색
2. 시작점 기준 BFS 탐색
3. 최댓값 저장
4. 완탐 후 출력
'''
def dfs(x, y):
    # 이미 메모이제이션된 지점이라면 탐색하지 않는다.
    if memo[x][y]:
        return memo[x][y]

    # 가본 곳 메모
    memo[x][y] = 1

    for dx, dy in dxy:
        mx, my = x + dx, y + dy

        # 그래프를 벗어나는 경우
        if 0 > mx or mx >= n or 0 > my or my >= n:
            continue

        # 먹을 수 있는 곳인 경우
        if graph[mx][my] > graph[x][y]:
            memo[x][y] = max(dfs(mx, my) + 1, memo[x][y])
    
    # 현재 위치로부터 가본 곳들의 최댓값 리턴
    return memo[x][y]


n = int(input())
graph = [list(map(int, input().split())) for _ in range(n)]
memo = [[0] * n for _ in range(n)]
dxy = [(1, 0), (-1, 0), (0, 1), (0, -1)]

# 전체 탐색
result = 0
for x in range(n):
    for y in range(n):
        result = max(dfs(x, y), result)

print(result)
